---
title: "Pattern wise practise 27 feb"
date: "2026-02-27"
tags: ["leetcode", "daily practise questions","Monotonic Stack"]

---

## Problem 1:
>**Monotonic Stack:** [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

**Rephrase problem**

Given a temperature in array , need to find the next hotter day to wait for each day 

```text
temperatures ; [73,74,75,71,69,72,76,73]
Output : [1,1,4,2,1,1,0,0]

|__pick i=0, val: 73 
|   |__ loop (1 to 7) -> i=1 
|   |__ ans[0] = 1-0;
|__pick i=1, val: 74
|   |__ loop (2 to 7) -> i=2
|   |__ ans[1] = 2-1 =1
|__pick i=2, val : 75
|   |__ loop (3 to 7) -> i=6
|   |__ ans[2] = 6-2 =4
|__pick i=3, val : 71
|   |__ loop (4 to 7) => i=5
|   |__ ans[3] = 5-3 =2
|__pick i=4, val : 69
|   |__ loop (5 to 7) => i=5
|   |__  ans [4] = 5-4 => 1
|__pick i=5 , val : 72 
|   |__ loop (6 to 7) => i=6
|   |__ ans[5] = 6-5 = 1
|__pick i=6 , val : 76
|   |__ loop (7 to 7) => i not found
|   |__ ans[6]=0
|__pick i=7, val : 73
    |__ ans[7] = 0


```

**Brute force**

1. pick one index
2. then iterate loop from index+1 to n
3. if find the first greater at index1-> for same index update to index1-index
4. if not find -> 0

>Time complexity will be O(n^2) and space will be O(n)

**code for Brute force**
```java
class Solution{
    public int[] dailyTemperatures(int[] temperatures){
        int n = temperatures.length;
        int[] ans = new int[n];
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                if(temperatures[j]>temperatures[i]){
                    ans[i] = j-i;
                    break;
                }
                ans[i]=0;
            }
        }
        ans[n-1]=0;
        return ans;
    }
}
```

**Dry run for brute force**

```text
t=[30,40,50,60]

|__pick i=0 (val:30)
|   |__ loop from 1 to 4
|       |__ 40>30 ? Yes 
|       |__ t[0] = 1-0=1
|__pick i=1, val=40
|   |__ loop from 2 to 4
|       |__ 40<50? Yes 
|       |__ t[1] =2-1 =1 
|__pick i=2, val=50
|   |__ loop from 3 to 4
|       |__ 60>50? yes
|       |__ t[2] = 3-2 =1

t[3]=0;

ans t=[1,1,1,0]

```

>it will give TLE 


**Optimize this solution**

Pattern : Monotonic stack to find the next greater element

```text
t = [73,74,75,71,69,72,76,73]

start from last element

|__pick i=7, val : 73
|   |__ stack is empty -> ans[7]=0
|   |__ stack=[73]
|__ pick i=6, val : 76
|   |__ stack is not empty 
|   |__ check while stack is empty or find the greater element
|       |__ 73>76? No pop() 
|   |__ stack is empty -> ans[6] = 0
|   |__ stack =[76]
|__pick i=5, val: 72
|   |__ stack is not empty
|   |__ check while stack is empty or find the greater element
|       |__ 76>72 ? Yes -> NEED TO STORE INDEX AS WELL ans[5] = 6-5 =1
|   |__ stack =[(72,5),(76,6)]
|__pick i=4, val:69
|   |__ stack is not empty
|   |__ check while stack is empty or find the greater element
|       |__ 72>69? Yes => ans[4] = 5-4 = 1
|   |__ stack =[(69,4),(72,5),(76,6)]
|__pick i=3, val : 71
|   |__check while stack is empty or find the greter element
|       |__ 69>71? No -> pop()
|       |__ 72>71? Yes -> ans [3] = 5-3 =2
|   |__ stack=[(71,3),(72,5),(76,6)]
|__pick i=2, val:75
|   |__ check while stack is empty or find the first greater element
|       |__ 71>75? No -> pop()
|       |__ 72>75? No -> pop()
|       |__ 76>75? Yes -> ans[2] = 6-2 = 4
|   |__ stack = [(75,2),(76,6)]
|__pick i=1 , val:74
|   |__ check while stack is empty or find the first greater element
|       |__ 75>74? Yes -> ans[1] = 2-1 =1
|   |__ stack =[(74,1),(75,2),(76,6)]
|__pick i=0, val : 73
    |__ check while stack is empty or find the first greater element
        |__ 74>73? Yes -> ans[0] = 1-0 = 1
    |__ stack = [(73,0),(74,1),(75,2),(76,6)]

Ans = [1,1,4,2,1,1,0,0]    
```

**Code for optimal Solution**
```java
class Pair{
    int val;
    int index;
    Pair(int val,int index){
        this.val=val;
        this.index=index;
    }
}
class Solution{
    public int[] dailyTemperatures(int[] t){
        int n = t.length;
        Stack<Pair> st = new Stack<>();
        int[] ans = new int[n];
        for(int i=n-1;i>=0;i--){
            while(!st.isEmpty() && st.peak().val<=t[i]){
                st.pop();
            }
            if(st.isEmpty()) ans[i]=0;
            else ans[i] = st.peak().index-i;
            
            st.push(new Pair(t[i],i));
        }
        return ans;
    }
}
```
> Time complexity => O(n) and space complexity: => O(n)